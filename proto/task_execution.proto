

syntax = "proto3";

package ga4gh_task_exec;

// Import HTTP RESTful annotations
import "google/api/annotations.proto";

//Parameters for Task
message TaskParameter {
  //OPTIONAL
  //name of the parameter
  string name = 1;
  //OPTIONAL
  //Text description
  string description = 2;
  //REQUIRED
  //location in long term storage, is a url specific to the implementing
  //system. For example s3://my-object-store/file1 or gs://my-bucket/file2 or
  //file:///path/to/my/file
  string location = 3;
  //REQUIRED
  //path in the machine file system. Note, this MUST be a path that exists
  //within one of the defined volumes
  //If the file is mounted in a volume that is mounted read/write the file must
  //be accessable to processes in the container. Optimizations, suc as hard linking
  //to a source file, or providing a streaming input from a FUSE mount should only
  //be done if the volume is mounted as read only
  string path = 4;
  //REQUIRED
  //Type of data, "File" or "Directory"
  //if used for an output all the files in the directory
  //will be copied to the storage location
  string class = 5;
  //OPTIONAL: default false
  //if the parameter is an output, should the element be created before executing
  //the command. For example if saving the working directory as an output,
  //the directory needs to exist before the command is called. If false, it is
  //assumed that the user will create the element as a part of the operation
  bool   create = 6;
}

//host to container port mappings
message Ports {
  //REQUIRED
  //Exposed port on container
  int32 container = 1;
  //OPTIONAL
  //Must be greater than 1024;
  //Defaults to 0
  int32 host = 2;
}

//A command line to be executed and the docker container to run it
message DockerExecutor {
  //REQUIRED
  //Docker Image name
  string imageName = 1;
  //REQUIRED
  //The command to be executed
  repeated string cmd = 2;
  //OPTIONAL: default docker image directory
  //The working directory that the command will be executed in
  string workdir = 3;
  //OPTIONAL
  //Path for supplying input to stdin, blank if none
  string stdin = 6;
  //OPTIONAL
  //Path for stdout recording, blank if not storing to file
  string stdout = 4;
  //OPTIONAL
  //Path for stderr recording, blank if not storing to file
  string stderr = 5;
  //OPTIONAL
  //Port to expose from within the container, blank if none
  repeated Ports ports = 7;
}

//Attached volume request.
message Volume {
  //OPTIONAL
  //Name of attached volume
  string name = 1;
  //REQUIRED
  //Minimum size
  double sizeGb = 2;
  //OPTIONAL
  //Source volume, this would refer to an existing volume the execution engine
  //could identify. Leave blank if is to be a newly created volume
  //Volumes loaded from a source will be mounted as read only
  string source = 3;
  //REQUIRED
  //mount point for volume inside the docker container
  string mountPoint = 6;
  //OPTIONAL default False
  bool readonly = 7;
}

message Resources {
  //OPTIONAL default 1
  //Minimum number of CPUs
  uint32 minimumCpuCores = 1;
  //Can schedule on resource that resource that can be preempted, like AWS Spot Instances
  //OPTIONAL default false
  bool preemptible = 2;
  //REQUIRED
  //Minimum RAM required
  double minimumRamGb = 3;
  //REQUIRED
  //Volumes to be mounted into the docker container
  repeated Volume volumes = 4;
  //OPTIONAL
  //optional scheduling information for systems where multiple compute zones are avalible
  repeated string zones = 5;
}

//The description of a task to be run
message Task {
  //OPTIONAL
  //user name for task
  string name = 1;
  //OPTIONAL
  //parameter for execution engine to define/store group information
  string projectID = 2;
  //OPTIONAL
  //free text description of task
  string description = 3;
  //REQUIRED
  //Files to be copied into system before tasks
  repeated TaskParameter inputs = 4;
  //REQUIRED
  //Files to be copied out of the system after tasks
  repeated TaskParameter outputs = 5;
  //REQUIRED
  //Define required system resources to run job
  Resources resources = 6;
  //REQUIRED
  //An array of docker executions that will be run sequentially
  repeated DockerExecutor docker = 8;
}

//Request listing of jobs tracked by server
message JobListRequest {
  //OPTIONAL
  //The name of the project to search for pipelines. Caller must have READ access to this project.
  string projectID = 1;
  //OPTIONAL
  //Pipelines with names that match this prefix should be returned. If unspecified, all pipelines in the project, up to pageSize, will be returned.
  string namePrefix	= 2;
  //OPTIONAL
  //Number of pipelines to return at once. Defaults to 256, and max is 2048.
  uint32 pageSize = 3;
  //OPTIONAL
  //Token to use to indicate where to start getting results. If unspecified, returns the first page of results.
  string pageToken = 4;
}

// Small description of tasks, returned by server during listing
message TaskDesc {
  //OPTIONAL
  //user name for task
  string name = 1;
  //OPTIONAL
  //parameter for execution engine to define/store group information
  string projectID = 2;
  //OPTIONAL
  //free text description of task
  string description = 3;
}

//Small description of jobs, returned by server during listing
message JobDesc {
  //REQUIRED
  string jobID  = 1;
  //REQUIRED
  State state = 2;
  // REQUIRED short description of task
  TaskDesc task = 3;
}

//Return envelope
message JobListResponse {
   repeated JobDesc jobs = 1;
   string nextPageToken = 2;
}

//ID of an instance of a Task
message JobID {
  string value = 1;
}

enum State {
  Unknown = 0;
  Queued = 1;
  Running = 2;
  Paused = 3;
  Complete = 4;
  Error = 5;
  SystemError = 6;
  Canceled = 7;
  Initializing = 8;
}

message JobLog {
  //The command line that was run
  repeated string cmd = 1;
  //When the command was executed
  string startTime = 2;
  //When the command completed
  string endTime = 3;
  //Sample of stdout (not guaranteed to be entire log)
  string stdout = 4;
  //Sample of stderr (not guaranteed to be entire log)
  string stderr = 5;
  //Exit code of the program
  int32  exitCode = 6;
  // ip of worker host
  string hostIP = 7;
  // ports bound from container to host
  repeated Ports ports = 8;
}


//Log of file output by workflow
message FileLog {
  //REQUIRED
  //location in long term storage that the output file was copied to
  //is a url specific to the implementing
  //system. For example s3://my-object-store/file1 or gs://my-bucket/file2 or
  //file:///path/to/my/file
  string location = 1;
  //REQUIRED
  //path in the machine file system that originated the file
  string path = 2;
  //REQUIRED
  //Size of produced file
  int64  size = 3;
}


//The description of the running instance of a task
message Job {
  string jobID = 1;
  map<string,string> metadata = 2;
  Task task = 3;
  State state = 4;
  repeated JobLog logs = 5;
  //List of all files copied out to the object store as well as some basic
  //meta-data about them. This is an expanded list, if the task outputs 
  //list directories, this record details every individual file
  repeated FileLog outputs = 6;
}

//Blank request message for service request
message ServiceInfoRequest {}

//Information about Task Execution Service
//May include information related (but not limited to)
//resource availability and storage system information
message ServiceInfo {
  //System specific key/value pairs
  //Example for a shared file system based storage system:
  //storageType=sharedFile, baseDir=/path/to/shared/directory
  map<string,string> storageConfig = 1;
}

//Web service to get, create, list and delete Tasks
service TaskService {

  //Get Service Info
  rpc GetServiceInfo(ServiceInfoRequest) returns (ServiceInfo) {
    option (google.api.http) = {
      get: "/v1/jobs-service"
    };
  }

  //Run a task
  rpc RunTask(Task) returns (JobID) {
    option (google.api.http) = {
      post: "/v1/jobs"
      body: "*"
    };
  }

  //List the TaskOps
  rpc ListJobs(JobListRequest) returns (JobListResponse) {
    option (google.api.http) = {
      get: "/v1/jobs"
    };
  }

  //Get info about a running task
  rpc GetJob(JobID) returns (Job) {
      option (google.api.http) = {
        get: "/v1/jobs/{value}"
      };
  }

  //Cancel a running task
  rpc CancelJob(JobID) returns (JobID) {
    option (google.api.http) = {
      delete: "/v1/jobs/{value}"
    };
  }

}
